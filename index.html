<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Periodic Delaunay-Voronoi - Three.js Visualization</title>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/",
            "poisson-disk-sampling": "https://esm.sh/poisson-disk-sampling@2.3.0"
        }
    }
    </script>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            width: 320px;
            transition: all 0.3s ease;
        }
        #controls-content {
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        .control-group {
            margin: 8px 0;
        }
        .control-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .control-row .control-group {
            flex: 1;
            margin: 0;
        }
        label {
            display: inline-block;
            width: 110px;
            font-size: 13px;
        }
        .control-row label {
            width: 80px;
        }
        input[type="number"] {
            width: 55px;
        }
        input[type="color"] {
            width: 30px;
            height: 25px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button {
            margin: 5px 0;
            padding: 5px 10px;
            width: 100%;
        }
        .section-header {
            font-weight: bold;
            margin: 15px 0 8px 0;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #controls-toggle {
            background: #007bff;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        #controls-toggle:hover {
            background: #0056b3;
        }
        #controls.hidden {
            width: auto;
            padding: 12px 16px;
        }
        #controls.hidden .section-header {
            margin: 0;
        }
        #controls.hidden #controls-toggle {
            padding: 8px 16px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .status { 
            font-size: 12px; 
            margin-top: 10px;
            padding: 5px;
            border-radius: 3px;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        
        /* Performance monitoring styles */
        .performance-stats {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
            font-size: 11px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
        
        .stat-label {
            color: #666;
        }
        
        .stat-value {
            font-family: monospace;
            color: #333;
            font-weight: bold;
        }
    </style>
</head>
<body>

    
    <div id="controls" class="controls-container">
        <button id="controls-toggle" title="Hide Controls">hide</button>
        <div id="controls-content">
            <div class="section" id="main-controls">
                <div class="section-header">Fabric of Space Y</div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Points:</label>
                        <input type="number" id="numPoints" value="250" min="4" max="2500" step="1">
                    </div>
                    <div class="control-group">
                        <label>Min Dist:</label>
                        <input type="number" id="minDistance" value="0.02" min="0.005" max="0.2" step="0.005">
                    </div>
                </div>

                <div class="control-row">
                    <div class="control-group">
                        <label>Periodic:</label>
                        <input type="checkbox" id="periodicMode">
                    </div>
                    <div class="control-group">
                        <label>Scale:</label>
                        <input type="range" id="boundaryScale" min="40" max="100" step="5" value="80" style="width: 60px;">
                        <span id="boundaryScaleValue" style="width: 40px; text-align: right;">80%</span>
                    </div>
                    <div class="control-group">
                        <label>Ghost Cells:</label>
                        <input type="checkbox" id="showGhostCells">
                    </div>
                    <div class="control-group">
                        <label>MIC:</label>
                        <input type="checkbox" id="useMIC">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Background:</label>
                        <input type="color" id="backgroundColor" value="#333333">
                    </div>
                    <div class="control-group">
                        <label>Boundary:</label>
                        <input type="checkbox" id="showBoundary">
                    </div>
                    <div class="control-group">
                        <label>Poisson:</label>
                        <input type="checkbox" id="poissonSampling" checked>
                    </div>
                </div>
            </div>
            
            <div class="section" id="visualization-controls">
                <div class="section-header">Delaunay Triangles / Tetrahedra</div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Vertices:</label>
                        <input type="checkbox" id="showVertices">
                    </div>
                    <div class="control-group">
                        <label>Delaunay:</label>
                        <input type="checkbox" id="showDelaunay">
                    </div>
                    <div class="control-group">
                        <label>Tetrahedra:</label>
                        <input type="checkbox" id="showTetrahedra">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Size:</label>
                        <input type="number" id="delaunaySize" value="0.008" min="0.005" max="0.05" step="0.001">
                    </div>
                    <div class="control-group">
                        <label>Color:</label>
                        <input type="color" id="vertexColor" value="#ffdd00">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Edge Width:</label>
                        <input type="number" id="delaunayEdgeWidth" value="2" min="1" max="5" step="1">
                    </div>
                    <div class="control-group">
                        <label>Color:</label>
                        <input type="color" id="delaunayEdgeColor" value="#4f4f4f">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Tetra Color:</label>
                        <input type="color" id="tetraColor" value="#888888">
                    </div>
                    <div class="control-group">
                        <label>Opacity:</label>
                        <input type="number" id="tetraOpacity" value="0.025" min="0.0" max="1.0" step="0.01">
                    </div>
                </div>
                
                <div class="section-header">Voronoi Diagrams</div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Vertices:</label>
                        <input type="checkbox" id="showVoronoiVertices">
                    </div>
                    <div class="control-group">
                        <label>Edges:</label>
                        <input type="checkbox" id="showVoronoiEdges">
                    </div>
                    <div class="control-group">
                        <label>Faces:</label>
                        <input type="checkbox" id="showVoronoiFaces">
                    </div>

                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Size: <span id="voronoiSizeValue">0.0025</span></label>
                        <input type="range" id="voronoiSize" min="0" max="0.0495" value="0.0475" step="0.0005" data-reversed="true">
                    </div>
                    <div class="control-group">
                        <label>Color:</label>
                        <input type="color" id="voronoiVertexColor" value="#bbbbbb">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Edge Width:</label>
                        <input type="number" id="voronoiEdgeWidth" value="3" min="1" max="5" step="1">
                    </div>
                    <div class="control-group">
                        <label>Color:</label>
                        <input type="color" id="voronoiEdgeColor" value="#000000">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Face Color:</label>
                        <input type="color" id="voronoiFaceColor" value="#32CD32">
                    </div>
                    <div class="control-group">
                        <label>Opacity:</label>
                        <input type="number" id="voronoiFaceOpacity" value="0.25" min="0.0" max="1.0" step="0.01">
                    </div>
                </div>

                
                <div class="section-header">Acuteness Detection</div>
                <div class="control-row">
                    <div class="control-group">
                        <label><input type="checkbox" id="vertexAnalysis" checked> Vertices</label>
                        <label style="margin-left: 10px;">Size:</label>
                        <input type="range" id="vertexThickness" min="0.005" max="0.05" step="0.001" value="0.010" style="width: 80px;">
                        <span id="vertexThicknessValue">0.010</span>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label><input type="checkbox" id="edgeAnalysis"> Edges</label>
                        <label style="margin-left: 10px;">Size:</label>
                        <input type="range" id="edgeThickness" min="0.005" max="0.05" step="0.001" value="0.010" style="width: 80px;">
                        <span id="edgeThicknessValue">0.010</span>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>
                            <select id="faceCellMode" style="margin-right: 5px;">
                                <option value="none">None</option>
                                <option value="faces">Faces</option>
                                <option value="cells" selected>Cells</option>
                            </select>
                        </label>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <button id="runTests">Run Unit Tests</button>
                    </div>
                    <div class="control-group">
                        <button id="recomputeAnalysis">Recompute Analysis</button>
                    </div>
                </div>

                <!-- Growth - Shrink Dynamics Controls -->
                <div class="section-header">Growth - Shrink Dynamics</div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Live Update:</label>
                        <input type="checkbox" id="liveUpdate" checked>
                    </div>
                    <div class="control-group">
                        <label>Update Step:</label>
                        <input type="number" id="updateFrequency" value="10" min="1" max="60" step="1">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Enable:</label>
                        <input type="checkbox" id="enableGrowth">
                    </div>
                    <div class="control-group">
                        <label>Growth Mode:</label>
                        <select id="growthMode" style="width: 100%;">
                            <option value="more_grow_only">+ Acute = + (only)</option>
                            <option value="more_grow_both" selected>+ Acute = + / - Acute = -</option>
                            <option value="more_shrink_only">+ Acute = - (only)</option>
                            <option value="more_shrink_both">+ Acute = - / - Acute = +</option>
                        </select>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group" style="width: 100%;">
                        <label style="width: 80px;">Threshold:</label>
                        <input type="range" id="growthThreshold" min="0" max="60" step="1" value="5" class="slider" style="flex: 1;">
                        <span id="growthThresholdValue" style="width: 30px; text-align: right;">5</span>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group" style="width: 100%;">
                        <label style="width: 80px;">Rate:</label>
                        <input type="range" id="growthRate" min="0.001" max="0.01" step="0.0001" value="0.005" class="slider" style="flex: 1;">
                        <span id="growthRateValue" style="width: 50px; text-align: right;">0.005</span>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group" style="width: 100%;">
                        <label style="width: 80px;">Damping:</label>
                        <input type="range" id="growthDamping" min="0" max="1" step="0.05" value="0.7" class="slider" style="flex: 1;">
                        <span id="growthDampingValue" style="width: 30px; text-align: right;">0.7</span>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group" style="width: 100%;">
                        <label style="width: 80px;">Max Delta:</label>
                        <input type="range" id="growthMaxDelta" min="0.001" max="0.1" step="0.001" value="0.02" class="slider" style="flex: 1;">
                        <span id="growthMaxDeltaValue" style="width: 50px; text-align: right;">0.02</span>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group" style="width: 100%;">
                        <label style="width: 80px;">Power:</label>
                        <input type="range" id="growthPower" min="0.5" max="3" step="0.1" value="1.5" class="slider" style="flex: 1;">
                        <span id="growthPowerValue" style="width: 30px; text-align: right;">1.5</span>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group" style="width: 100%;">
                        <label style="width: 80px;">Force Str:</label>
                        <input type="range" id="forceStrength" min="0.1" max="10.0" step="0.1" value="5.0" class="slider" style="flex: 1;">
                        <span id="forceStrengthValue" style="width: 30px; text-align: right;">5.0</span>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group" style="width: 100%;">
                        <label style="width: 80px;">Precision:</label>
                        <input type="range" id="equilibriumPrecision" min="0.0001" max="0.01" step="0.0001" value="0.0005" class="slider" style="flex: 1;">
                        <span id="equilibriumPrecisionValue" style="width: 50px; text-align: right;">0.0005</span>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group" style="width: 100%;">
                        <label style="width: 80px;">Max Steps:</label>
                        <input type="range" id="maxPhysicsSteps" min="10" max="500" step="10" value="100" class="slider" style="flex: 1;">
                        <span id="maxPhysicsStepsValue" style="width: 50px; text-align: right;">100</span>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group" style="width: 100%;">
                        <label style="width: 80px;">Phys/Anal:</label>
                        <input type="range" id="physicsStepsPerAnalysis" min="1" max="50" step="1" value="10" class="slider" style="flex: 1;">
                        <span id="physicsStepsPerAnalysisValue" style="width: 30px; text-align: right;">10</span>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Step Mode:</label>
                        <select id="stepMode" style="width: 120px;">
                            <option value="manual">Manual</option>
                            <option value="auto">Auto</option>
                            <option value="equilibrium">Equilibrium</option>
                            <option value="continuous">Continuous</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <button id="manualStep" style="width: 100px;">Manual Step</button>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Normalize:</label>
                        <input type="checkbox" id="growthNormalize" checked>
                    </div>
                    <div class="control-group">
                        <button id="resetGrowth">Reset</button>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group" style="width: 100%;">
                        <span id="growthStats" style="font-size: 11px; color: #666;">Dynamics inactive</span>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group" style="width: 100%;">
                        <span id="physicsStats" style="font-size: 10px; color: #888;">Physics: 0 steps | Equilibrium: No</span>
                    </div>
                </div>

                <!-- Performance Monitoring -->
                <div class="section-header">Performance Monitor</div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Show Stats:</label>
                        <input type="checkbox" id="showPerformanceStats">
                    </div>
                </div>
                <div id="performanceStats" class="performance-stats" style="display: none;">
                    <div class="stat-row">
                        <span class="stat-label">Total Time:</span>
                        <span class="stat-value" id="perfTotalTime">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Acuteness:</span>
                        <span class="stat-value" id="perfAcutenessTime">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Physics:</span>
                        <span class="stat-value" id="perfPhysicsTime">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Voronoi:</span>
                        <span class="stat-value" id="perfVoronoiTime">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Active Cells:</span>
                        <span class="stat-value" id="perfActiveCells">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Avg Neighbors:</span>
                        <span class="stat-value" id="perfAvgNeighbors">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">FPS:</span>
                        <span class="stat-value" id="perfFPS">-</span>
                    </div>
                </div>

                
                <button id="regenerate">Generate New Points</button>
                <button id="recompute">Recompute Triangulation</button>
                <div id="status" class="status"></div>

            </div>
        </div>
    </div>
    
    <script src="dist/periodic_delaunay.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
        import { DelaunayComputation } from './src/js/DelaunayComputation.js';
        import * as GeometryAnalysis from './src/js/GeometryAnalysis.js';
        import * as Visualizer from './src/js/Visualizer.js';
        import { runGeometryAnalysisTests } from './test/GeometryAnalysis.test.js';
        import { parallelAcutenessAnalysis } from './src/js/WorkerManager.js';
        import { FastAcutenessAnalyzer } from './src/js/FastAcuteness.js';
        import { PhysicsGrowthSystem } from './src/js/PhysicsGrowthSystem.js';
        import PoissonDiskSampling from 'poisson-disk-sampling';
        
        // Add early event listener for debugging
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, checking for regenerate button...');
            const testButton = document.getElementById('regenerate');
            if (testButton) {
                console.log('Regenerate button found in DOM!');
                testButton.addEventListener('click', () => {
                    console.log('Early event listener triggered!');
                });
            } else {
                console.error('Regenerate button NOT found in DOM!');
            }
        });
        
        let scene, camera, renderer, controls;
        let verticesGroup, delaunayGroup, voronoiVerticesGroup, voronoiEdgesGroup, tetrahedraGroup, boundaryGroup, voronoiFacesGroup;
        let mainCellGroup, ghostCellsGroup; // NEW: Groups for ghost cell tiling
        let Module;
        let currentPoints = [];
        let computation = null;
        let fastAnalyzer = null;
        let physicsGrowthSystem = null;
        let velocities = [];
        let frameCount = 0;
        let growthEnabled = false;
        
        // Performance monitoring variables
        let lastFPSUpdate = performance.now();
        let currentFPS = 0;
        
        // ACUTENESS ANALYSIS: Global variables for analysis results
        let analysisResults = null;
        let savedLegendOpacities = {}; // Store opacity settings globally to persist across updates
        let lastAnalysisTime = 0;
        const ANALYSIS_THROTTLE_MS = 100; // Minimum time between analyses

        
        // Initialize Three.js
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(document.getElementById('backgroundColor').value);
            
            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.set(1.5, 1.5, 1.5);
            camera.lookAt(0.5, 0.5, 0.5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0.5, 0.5, 0.5);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Groups
            verticesGroup = new THREE.Group();
            delaunayGroup = new THREE.Group();
            voronoiVerticesGroup = new THREE.Group();
            voronoiEdgesGroup = new THREE.Group();
            tetrahedraGroup = new THREE.Group();
            boundaryGroup = new THREE.Group();
            voronoiFacesGroup = new THREE.Group();
            
            // NEW: Ghost cell groups
            mainCellGroup = new THREE.Group();
            ghostCellsGroup = new THREE.Group();
            
            // Add main cell groups to the main cell container
            mainCellGroup.add(verticesGroup);
            mainCellGroup.add(delaunayGroup);
            mainCellGroup.add(voronoiVerticesGroup);
            mainCellGroup.add(voronoiEdgesGroup);
            mainCellGroup.add(tetrahedraGroup);
            mainCellGroup.add(voronoiFacesGroup);
            
            scene.add(mainCellGroup);
            scene.add(boundaryGroup); // Boundary stays separate
            scene.add(ghostCellsGroup);
            
            // Create boundary box
            createBoundaryBox();
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Update resolution for LineMaterial
            delaunayGroup.children.forEach(child => {
                if (child.material && child.material.isLineMaterial) {
                    child.material.resolution.set(window.innerWidth, window.innerHeight);
                }
            });
            voronoiVerticesGroup.children.forEach(child => {
                if (child.material && child.material.isLineMaterial) {
                    child.material.resolution.set(window.innerWidth, window.innerHeight);
                }
            });
            voronoiEdgesGroup.children.forEach(child => {
                if (child.material && child.material.isLineMaterial) {
                    child.material.resolution.set(window.innerWidth, window.innerHeight);
                }
            });
        }
        
        function createBoundaryBox() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 })
            );
            line.position.set(0.5, 0.5, 0.5);
            boundaryGroup.add(line);
            
            // Add axes helpers to boundary group so they hide together
            const axesHelper = new THREE.AxesHelper(0.2);
            boundaryGroup.add(axesHelper);
        }
        
        // Generate well-distributed points using Poisson disk sampling
        function generatePoissonPoints(targetCount, minDistance) {
            console.log(`Generating ~${targetCount} points with min distance ${minDistance}...`);
            
            // Get boundary scale factor
            const scale = parseFloat(document.getElementById('boundaryScale').value) / 100.0;
            const offset = (1 - scale) / 2; // Center the scaled region
            
            // For now, use a simpler approach that works better
            const points = [];
            const maxAttempts = targetCount * 100;
            let attempts = 0;
            
            // Add small margin to keep points away from boundaries
            const margin = 0.01 * scale; // Scale the margin too
            
            while (points.length < targetCount && attempts < maxAttempts) {
                attempts++;
                const newPoint = [
                    offset + margin + Math.random() * (scale - 2 * margin),
                    offset + margin + Math.random() * (scale - 2 * margin),
                    offset + margin + Math.random() * (scale - 2 * margin)
                ];
                
                // Check minimum distance to existing points
                let tooClose = false;
                for (const point of points) {
                    const dx = newPoint[0] - point[0];
                    const dy = newPoint[1] - point[1];
                    const dz = newPoint[2] - point[2];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist < minDistance) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    points.push(newPoint);
                }
            }
            
            console.log(`Generated ${points.length} points with minimum distance checking, scale=${scale}`);
            
            // If we couldn't generate enough points, warn the user
            if (points.length < targetCount * 0.8) {
                console.warn(`Only generated ${points.length}/${targetCount} points. Consider reducing Min Dist or unchecking Poisson Sampling.`);
                setStatus(`Only generated ${points.length}/${targetCount} points. Try reducing Min Dist to ${(minDistance * 0.7).toFixed(3)} or uncheck Poisson Sampling.`, false);
            }
            
            return points;
        }
        
        // Legacy function for comparison (keeping for now)
        function generateWellDistributedPoints(count, minDist) {
            // Get boundary scale factor
            const scale = parseFloat(document.getElementById('boundaryScale').value) / 100.0;
            const offset = (1 - scale) / 2; // Center the scaled region
            
            const points = [];
            let attempts = 0;
            const maxAttempts = count * 1000;
            
            while (points.length < count && attempts < maxAttempts) {
                attempts++;
                const newPoint = [
                    offset + Math.random() * scale,
                    offset + Math.random() * scale,
                    offset + Math.random() * scale
                ];
                
                // Check distance to existing points
                let tooClose = false;
                for (const point of points) {
                    const dx = newPoint[0] - point[0];
                    const dy = newPoint[1] - point[1];
                    const dz = newPoint[2] - point[2];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    if (dist < minDist) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    points.push(newPoint);
                }
            }
            
            console.log(`Generated ${points.length} points with scale=${scale}`);
            return points;
        }
        
        // Helper function to calculate minimum image for periodic boundaries
        function getMinimumImage(p1, p2) {
            let dx = p2[0] - p1[0];
            let dy = p2[1] - p1[1];
            let dz = p2[2] - p1[2];

            // Apply periodic boundary conditions
            if (dx > 0.5) dx -= 1.0; else if (dx < -0.5) dx += 1.0;
            if (dy > 0.5) dy -= 1.0; else if (dy < -0.5) dy += 1.0;
            if (dz > 0.5) dz -= 1.0; else if (dz < -0.5) dz += 1.0;

            return [p1[0] + dx, p1[1] + dy, p1[2] + dz];
        }

        // NEW: Simple line functions for better performance (width parameter kept for compatibility)
        function createDelaunayEdgesThick(computation, width, material) {
            const delaunayEdgeSet = new Set();
            const positions = [];

            for (const tet of computation.tetrahedra) {
                const edges = [
                    [tet[0], tet[1]], [tet[0], tet[2]], [tet[0], tet[3]], 
                    [tet[1], tet[2]], [tet[1], tet[3]], [tet[2], tet[3]]
                ];
                
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (!delaunayEdgeSet.has(key)) {
                        delaunayEdgeSet.add(key);
                        
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.pointsArray[b];
                        
                        if (computation.isPeriodic) {
                            const p2_mic = getMinimumImage(p1, p2);
                            positions.push(p1[0], p1[1], p1[2]);
                            positions.push(p2_mic[0], p2_mic[1], p2_mic[2]);
                        } else {
                            positions.push(p1[0], p1[1], p1[2]);
                            positions.push(p2[0], p2[1], p2[2]);
                        }
                    }
                }
            }

            if (positions.length === 0) return;

            const geometry = new LineGeometry();
            geometry.setPositions(positions);

            const lineMaterial = new LineMaterial({
                color: material.color.getHex(),
                linewidth: width,
                resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),
                linecap: 'square',
                linejoin: 'miter'
            });

            const line = new Line2(geometry, lineMaterial);
            line.computeLineDistances();
            delaunayGroup.add(line);
        }

        function createVoronoiEdgesThick(computation, width, material) {
            if (computation.voronoiEdges.length === 0) return;
            
            const positions = [];
            for (const edge of computation.voronoiEdges) {
                const p1 = edge.start;
                const p2 = edge.end;
                
                if (computation.isPeriodic) {
                    const p2_mic = getMinimumImage(p1, p2);
                    positions.push(p1[0], p1[1], p1[2]);
                    positions.push(p2_mic[0], p2_mic[1], p2_mic[2]);
                } else {
                    positions.push(p1[0], p1[1], p1[2]);
                    positions.push(p2[0], p2[1], p2[2]);
                }
            }

            const geometry = new LineGeometry();
            geometry.setPositions(positions);

            const lineMaterial = new LineMaterial({
                color: material.color.getHex(),
                linewidth: width,
                resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),
                linecap: 'square',
                linejoin: 'miter'
            });

            const line = new Line2(geometry, lineMaterial);
            line.computeLineDistances();
            voronoiEdgesGroup.add(line);
        }

        // NEW: MIC-based edge drawing function (Phase 2 implementation)
        function createDelaunayEdgesMIC(computation) {
            const points = [];
            const delaunayEdgeSet = new Set();
            
            // Extract unique edges from tetrahedra
            for (const tet of computation.tetrahedra) {
                const edges = [
                    [tet[0], tet[1]], [tet[0], tet[2]], [tet[0], tet[3]], 
                    [tet[1], tet[2]], [tet[1], tet[3]], [tet[2], tet[3]]
                ];
                
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (!delaunayEdgeSet.has(key)) {
                        delaunayEdgeSet.add(key);
                        
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.pointsArray[b];
                        
                        if (computation.isPeriodic) {
                            const p2_mic = getMinimumImage(p1, p2);
                            points.push(p1[0], p1[1], p1[2]);
                            points.push(p2_mic[0], p2_mic[1], p2_mic[2]);
                        } else {
                            points.push(p1[0], p1[1], p1[2]);
                            points.push(p2[0], p2[1], p2[2]);
                        }
                    }
                }
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            return geometry;
        }

        // NEW: Enhanced Voronoi edge drawing with MIC
        function createVoronoiEdgesMIC(computation) {
            if (computation.voronoiEdges.length === 0) return null;
            
            const points = [];
            for (const edge of computation.voronoiEdges) {
                const p1 = edge.start;
                const p2 = edge.end;
                
                if (computation.isPeriodic) {
                    const p2_mic = getMinimumImage(p1, p2);
                    points.push(p1[0], p1[1], p1[2]);
                    points.push(p2_mic[0], p2_mic[1], p2_mic[2]);
                } else {
                    points.push(p1[0], p1[1], p1[2]);
                    points.push(p2[0], p2[1], p2[2]);
                }
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            return geometry;
        }



        // NEW: Ghost Cell Tiling (Phase 3 implementation)
        function createGhostCellTiling() {
            ghostCellsGroup.children.forEach(child => {
                if (child.isGroup) {
                    child.children.forEach(c => {
                        if (c.geometry) c.geometry.dispose();
                        if (c.material) c.material.dispose();
                    });
                }
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            ghostCellsGroup.clear();
            
            if (!computation || !document.getElementById('showGhostCells').checked) {
                return;
            }
            
            console.log("Creating ghost cell tiling...");
            
            // Define the 26 neighboring cell positions (excluding center at [0,0,0])
            const ghostOffsets = [];
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        if (x !== 0 || y !== 0 || z !== 0) { // Skip center cell
                            ghostOffsets.push([x, y, z]);
                        }
                    }
                }
            }
            
            // Semi-transparent materials for ghost cells
            const delaunayEdgeColorHex = document.getElementById('delaunayEdgeColor').value;
            const delaunayEdgeColorInt = parseInt(delaunayEdgeColorHex.substring(1), 16);
            const ghostDelaunayMaterial = new THREE.LineBasicMaterial({ 
                color: delaunayEdgeColorInt, 
                opacity: 0.3, 
                transparent: true 
            });
            
            const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
            const voronoiEdgeColorInt = parseInt(voronoiEdgeColorHex.substring(1), 16);
            const ghostVoronoiMaterial = new THREE.LineBasicMaterial({ 
                color: voronoiEdgeColorInt, 
                opacity: 0.2, 
                transparent: true
            });
            
            const vertexColorHex = document.getElementById('vertexColor').value;
            const vertexColorInt = parseInt(vertexColorHex.substring(1), 16);
            const ghostVertexMaterial = new THREE.MeshPhongMaterial({ 
                color: vertexColorInt, 
                opacity: 0.4, 
                transparent: true 
            });
            
            // Create ghost geometries
            const delaunayGeometry = createDelaunayEdgesMIC(computation);
            const voronoiGeometry = createVoronoiEdgesMIC(computation);
            
            // Create ghost cells for each offset
            for (const [offsetX, offsetY, offsetZ] of ghostOffsets) {
                const ghostGroup = new THREE.Group();
                ghostGroup.position.set(offsetX, offsetY, offsetZ);
                
                // Add Delaunay edges
                if (delaunayGeometry && document.getElementById('showDelaunay').checked) {
                    const ghostDelaunayLines = new THREE.LineSegments(
                        delaunayGeometry.clone(), 
                        ghostDelaunayMaterial
                    );
                    ghostGroup.add(ghostDelaunayLines);
                }
                
                // Add Voronoi edges
                if (voronoiGeometry && document.getElementById('showVoronoiEdges').checked) {
                    const ghostVoronoiLines = new THREE.LineSegments(
                        voronoiGeometry.clone(), 
                        ghostVoronoiMaterial
                    );
                    ghostGroup.add(ghostVoronoiLines);
                }
                
                // Add Voronoi faces with same random coloring as main cell
                if (document.getElementById('showVoronoiFaces').checked && computation.tetrahedra.length > 0) {
                    // Get face color from input
                    const faceColorHex = document.getElementById('voronoiFaceColor').value;
                    const faceColorInt = parseInt(faceColorHex.substring(1), 16);
                    const baseOpacity = parseFloat(document.getElementById('voronoiFaceOpacity').value);
                    const opacity = baseOpacity * 0.3; // More transparent for ghost
                    
                    // Create ghost Voronoi cells
                    const cells = new Map();
                    computation.tetrahedra.forEach((tet, index) => {
                        const barycenter = computation.barycenters[index];
                        if (!barycenter) return;

                        tet.forEach(vertexIndex => {
                            if (!cells.has(vertexIndex)) {
                                cells.set(vertexIndex, []);
                            }
                            cells.get(vertexIndex).push(new THREE.Vector3(...barycenter));
                        });
                    });

                    cells.forEach((cellVertices, vertexIndex) => {
                        if (cellVertices.length < 4) return;

                        const geometry = new ConvexGeometry(cellVertices);
                        
                        // Default ghost material
                        const material = new THREE.MeshPhongMaterial({
                            color: faceColorInt,
                            opacity: opacity,
                            transparent: true,
                            side: THREE.DoubleSide,
                            depthWrite: false
                        });
                        
                        const mesh = new THREE.Mesh(geometry, material);
                        ghostGroup.add(mesh);
                    });
                }
                
                // Add vertices
                if (document.getElementById('showVertices').checked) {
                    const vertexSize = parseFloat(document.getElementById('delaunaySize').value);
                    const sphereGeometry = new THREE.SphereGeometry(vertexSize, 8, 8);
                    
                    for (const point of computation.pointsArray) {
                        const sphere = new THREE.Mesh(sphereGeometry, ghostVertexMaterial);
                        sphere.position.set(point[0], point[1], point[2]);
                        ghostGroup.add(sphere);
                    }
                }
                
                ghostCellsGroup.add(ghostGroup);
            }
            
            console.log(`Created ${ghostOffsets.length} ghost cells`);
        }

        // Legacy boundary clipping approach (for comparison)
        function drawMeshesLegacy(computation, delaunayMaterial, voronoiMaterial) {
            const delaunayPeriodicMaterial = new THREE.LineBasicMaterial({ 
                color: delaunayMaterial.color, 
                opacity: 0.6, 
                transparent: true 
            });
            const voronoiPeriodicMaterial = new THREE.LineBasicMaterial({ 
                color: voronoiMaterial.color, 
                opacity: 0.8, 
                transparent: true 
            });
            
            let periodicEdgeCount = 0;
            let regularEdgeCount = 0;
            
            // --- Draw Delaunay Edges with Legacy Clipping ---
            const delaunayEdgeSet = new Set();
            for (const tet of computation.tetrahedra) {
                const edges = [
                    [tet[0], tet[1]], [tet[0], tet[2]], [tet[0], tet[3]], 
                    [tet[1], tet[2]], [tet[1], tet[3]], [tet[2], tet[3]]
                ];
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (!delaunayEdgeSet.has(key)) {
                        delaunayEdgeSet.add(key);
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.pointsArray[b];
                        
                        if (computation.isPeriodic) {
                            const p2min = getMinimumImage(p1, p2);
                            const isPeriodic = (p2min[0] !== p2[0] || p2min[1] !== p2[1] || p2min[2] !== p2[2]);
                            
                            if (isPeriodic) {
                                periodicEdgeCount++;
                                // OLD: Boundary clipping approach
                                for (let dim = 0; dim < 3; dim++) {
                                    const diff = p2[dim] - p1[dim];
                                    if (Math.abs(diff) > 0.5) {
                                        const t = diff > 0 ? (1.0 - p1[dim]) / diff : (0.0 - p1[dim]) / diff;
                                        const tClamped = Math.max(0.001, Math.min(0.999, t));
                                        
                                        const midPoint = [
                                            p1[0] + tClamped * (p2[0] - p1[0]),
                                            p1[1] + tClamped * (p2[1] - p1[1]),
                                            p1[2] + tClamped * (p2[2] - p1[2])
                                        ];
                                        midPoint[dim] = diff > 0 ? 0.999 : 0.001;
                                        
                                        // Draw first segment to boundary
                                        const geom1 = new THREE.BufferGeometry().setFromPoints([
                                            new THREE.Vector3(...p1),
                                            new THREE.Vector3(...midPoint)
                                        ]);
                                        delaunayGroup.add(new THREE.Line(geom1, delaunayPeriodicMaterial));
                                        
                                        // Draw second segment from opposite boundary
                                        const oppositePoint = [...midPoint];
                                        oppositePoint[dim] = diff > 0 ? 0.001 : 0.999;
                                        const geom2 = new THREE.BufferGeometry().setFromPoints([
                                            new THREE.Vector3(...oppositePoint),
                                            new THREE.Vector3(...p2)
                                        ]);
                                        delaunayGroup.add(new THREE.Line(geom2, delaunayPeriodicMaterial));
                                        break;
                                    }
                                }
                            } else {
                                regularEdgeCount++;
                                const lineGeom = new THREE.BufferGeometry().setFromPoints([
                                    new THREE.Vector3(...p1), new THREE.Vector3(...p2)
                                ]);
                                delaunayGroup.add(new THREE.Line(lineGeom, delaunayMaterial));
                            }
                        } else {
                            const lineGeom = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(...p1), new THREE.Vector3(...p2)
                            ]);
                            delaunayGroup.add(new THREE.Line(lineGeom, delaunayMaterial));
                        }
                    }
                }
            }
            
            // --- Draw Voronoi Edges with Legacy Clipping ---
            for (const edge of computation.voronoiEdges) {
                const p1 = edge.start;
                const p2 = edge.end;
                
                if (computation.isPeriodic) {
                    const p2min = getMinimumImage(p1, p2);
                    const isPeriodic = (p2min[0] !== p2[0] || p2min[1] !== p2[1] || p2min[2] !== p2[2]);
                    
                    if (isPeriodic) {
                        for (let dim = 0; dim < 3; dim++) {
                            const diff = p2[dim] - p1[dim];
                            if (Math.abs(diff) > 0.5) {
                                const t = diff > 0 ? (1.0 - p1[dim]) / diff : (0.0 - p1[dim]) / diff;
                                const tClamped = Math.max(0.001, Math.min(0.999, t));
                                
                                const midPoint = [
                                    p1[0] + tClamped * (p2[0] - p1[0]),
                                    p1[1] + tClamped * (p2[1] - p1[1]),
                                    p1[2] + tClamped * (p2[2] - p1[2])
                                ];
                                midPoint[dim] = diff > 0 ? 0.999 : 0.001;
                                
                                const geom1 = new THREE.BufferGeometry().setFromPoints([
                                    new THREE.Vector3(...p1),
                                    new THREE.Vector3(...midPoint)
                                ]);
                                voronoiEdgesGroup.add(new THREE.Line(geom1, voronoiPeriodicMaterial));
                                
                                const oppositePoint = [...midPoint];
                                oppositePoint[dim] = diff > 0 ? 0.001 : 0.999;
                                const geom2 = new THREE.BufferGeometry().setFromPoints([
                                    new THREE.Vector3(...oppositePoint),
                                    new THREE.Vector3(...p2)
                                ]);
                                voronoiEdgesGroup.add(new THREE.Line(geom2, voronoiPeriodicMaterial));
                                break;
                            }
                        }
                    } else {
                        const lineGeom = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(...p1), new THREE.Vector3(...p2)
                        ]);
                        voronoiEdgesGroup.add(new THREE.Line(lineGeom, voronoiMaterial));
                    }
                } else {
                    const lineGeom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(...p1), new THREE.Vector3(...p2)
                    ]);
                    voronoiEdgesGroup.add(new THREE.Line(lineGeom, voronoiMaterial));
                }
            }
            
            console.log(`Legacy: Drew ${periodicEdgeCount} periodic edges (clipped), ${regularEdgeCount} regular edges`);
        }

        // Visualize vertices
        function drawVertices(computation) {
            // Dispose of old geometries and materials
            verticesGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            verticesGroup.clear();
            
            const vertexSize = parseFloat(document.getElementById('delaunaySize').value);
            const vertexColorHex = document.getElementById('vertexColor').value;
            const vertexColorInt = parseInt(vertexColorHex.substring(1), 16);
            
            const geometry = new THREE.SphereGeometry(vertexSize, 16, 16);
            const material = new THREE.MeshPhongMaterial({ color: vertexColorInt });
            
            if (computation.isPeriodic) {
                // In periodic mode: show original vertices + periodic copies that contribute to visible cells
                const shownVertices = new Set();
                
                // First, show all original vertices
                for (let i = 0; i < computation.pointsArray.length; i++) {
                    const point = computation.pointsArray[i];
                    const key = `${point[0].toFixed(6)},${point[1].toFixed(6)},${point[2].toFixed(6)}`;
                    if (!shownVertices.has(key)) {
                        shownVertices.add(key);
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(point[0], point[1], point[2]);
                        verticesGroup.add(sphere);
                    }
                }
                
                // Then, for cells that extend beyond boundaries, show periodic copies of vertices
                const cells = new Map();
                computation.tetrahedra.forEach((tet, index) => {
                    const barycenter = computation.barycenters[index];
                    if (!barycenter) return;

                    tet.forEach(vertexIndex => {
                        if (!cells.has(vertexIndex)) {
                            cells.set(vertexIndex, []);
                        }
                        cells.get(vertexIndex).push(barycenter);
                    });
                });
                
                // For each cell, if barycenters extend beyond [0,1], show periodic vertex copies
                cells.forEach((cellBarycenters, vertexIndex) => {
                    if (vertexIndex >= computation.pointsArray.length) return;
                    
                    const hasExternalBarycenter = cellBarycenters.some(b => 
                        b[0] < 0 || b[0] > 1 || b[1] < 0 || b[1] > 1 || b[2] < 0 || b[2] > 1
                    );
                    
                    if (hasExternalBarycenter) {
                        const originalVertex = computation.pointsArray[vertexIndex];
                        
                        // Show periodic copies in all 27 positions
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dz = -1; dz <= 1; dz++) {
                                    if (dx === 0 && dy === 0 && dz === 0) continue; // Skip original
                                    
                                    const periodicVertex = [
                                        originalVertex[0] + dx,
                                        originalVertex[1] + dy,
                                        originalVertex[2] + dz
                                    ];
                                    
                                    const key = `${periodicVertex[0].toFixed(6)},${periodicVertex[1].toFixed(6)},${periodicVertex[2].toFixed(6)}`;
                                    if (!shownVertices.has(key)) {
                                        shownVertices.add(key);
                                        const sphere = new THREE.Mesh(geometry, material);
                                        sphere.position.set(periodicVertex[0], periodicVertex[1], periodicVertex[2]);
                                        verticesGroup.add(sphere);
                                    }
                                }
                            }
                        }
                    }
                });
            } else {
                // In non-periodic mode: show only original vertices
                for (const point of computation.pointsArray) {
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.set(point[0], point[1], point[2]);
                    verticesGroup.add(sphere);
                }
            }
        }
        
        // Visualize Delaunay edges
        function drawDelaunay(computation) {
            delaunayGroup.clear();
            
            if (computation.tetrahedra.length === 0) return;
            
            const edgeSet = new Set();
            const material = new THREE.LineBasicMaterial({ color: 0x0066ff });
            const periodicMaterial = new THREE.LineBasicMaterial({ 
                color: 0x0099ff
            });
            
            // Extract unique edges from tetrahedra
            for (const tet of computation.tetrahedra) {
                const edges = [
                    [tet[0], tet[1]], [tet[0], tet[2]], [tet[0], tet[3]],
                    [tet[1], tet[2]], [tet[1], tet[3]], [tet[2], tet[3]]
                ];
                
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (!edgeSet.has(key)) {
                        edgeSet.add(key);
                        
                        // Get vertex positions
                        const p1 = computation.pointsArray[a];
                        const p2 = computation.pointsArray[b];
                        
                        // Check if edge crosses periodic boundary
                        const isPeriodic = computation._isPeriodicEdge(p1, p2);
                        
                        const geometry = new THREE.BufferGeometry();
                        const positions = new Float32Array([
                            p1[0], p1[1], p1[2],
                            p2[0], p2[1], p2[2]
                        ]);
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        
                        const line = new THREE.Line(
                            geometry, 
                            isPeriodic ? periodicMaterial : material
                        );
                        delaunayGroup.add(line);
                    }
                }
            }
        }
        
        // Visualize Voronoi edges
        function drawVoronoi(computation) {
            voronoiVerticesGroup.clear();
            voronoiEdgesGroup.clear();
            
            if (computation.voronoiEdges.length === 0) return;
            
            // Get edge color
            const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
            const voronoiEdgeColorInt = parseInt(voronoiEdgeColorHex.substring(1), 16);
            
            const material = new THREE.LineBasicMaterial({ 
                color: voronoiEdgeColorInt
            });
            const periodicMaterial = new THREE.LineBasicMaterial({ 
                color: voronoiEdgeColorInt,
                opacity: 0.8,
                transparent: true
            });
            
            for (const edge of computation.voronoiEdges) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array([
                    edge.start[0], edge.start[1], edge.start[2],
                    edge.end[0], edge.end[1], edge.end[2]
                ]);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const line = new THREE.Line(
                    geometry, 
                    edge.isPeriodic ? periodicMaterial : material
                );
                voronoiEdgesGroup.add(line);
            }
            
            // Also draw the barycenters as small spheres
            const voronoiSizeSliderValue = parseFloat(document.getElementById('voronoiSize').value);
            const voronoiVertexSize = 0.05 - voronoiSizeSliderValue; // Convert from reversed slider
            const voronoiVertexColorHex = document.getElementById('voronoiVertexColor').value;
            const voronoiVertexColorInt = parseInt(voronoiVertexColorHex.substring(1), 16);
            
            const sphereGeometry = new THREE.SphereGeometry(voronoiVertexSize, 8, 8);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: voronoiVertexColorInt,
                emissive: voronoiVertexColorInt,
                emissiveIntensity: 0.3
            });
            
            for (const center of computation.barycenters) {
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(center[0], center[1], center[2]);
                voronoiVerticesGroup.add(sphere);
            }
        }
        
        // Draw Voronoi faces with default styling
        function drawVoronoiFaces(computation) {
            voronoiFacesGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            voronoiFacesGroup.clear();
            
            if (!computation.tetrahedra.length || !computation.barycenters.length) return;
            
            // Get face color and opacity from inputs
            const faceColorHex = document.getElementById('voronoiFaceColor').value;
            const faceColorInt = parseInt(faceColorHex.substring(1), 16);
            const faceOpacity = parseFloat(document.getElementById('voronoiFaceOpacity').value);
            
            // Default material
            const defaultMaterial = new THREE.MeshPhongMaterial({
                color: faceColorInt,
                opacity: faceOpacity,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false // Important for transparent objects
            });
            
            // Map each original vertex to the barycenters of tetrahedra that contain it
            const cells = new Map();
            computation.tetrahedra.forEach((tet, index) => {
                const barycenter = computation.barycenters[index];
                if (!barycenter) return;

                tet.forEach(vertexIndex => {
                    if (!cells.has(vertexIndex)) {
                        cells.set(vertexIndex, []);
                    }
                    cells.get(vertexIndex).push(barycenter); // Store as array, not THREE.Vector3 yet
                });
            });

            // For each cell, compute the convex hull
            let cellIndex = 0;
            
            // Debug: log first few cells to understand the issue
            // Cell drawing
            cells.forEach((cellBarycenters, vertexIndex) => {
                if (cellBarycenters.length < 4) return; // Need at least 4 points for a 3D shape

                // Apply MIC correction for periodic cells to prevent transverse connections
                let vertices;
                if (computation.isPeriodic && cellBarycenters.length > 0) {
                    // Apply MIC: Use first barycenter as reference, correct others to same periodic image
                    const reference = cellBarycenters[0];
                    vertices = cellBarycenters.map(barycenter => {
                        if (barycenter === reference) {
                            return new THREE.Vector3(...reference);
                        }
                        
                        // Apply MIC to bring barycenter to same periodic image as reference
                        const corrected = getMinimumImage(reference, barycenter);
                        return new THREE.Vector3(...corrected);
                    });
                    

                } else {
                    // Non-periodic: use barycenters as-is
                    vertices = cellBarycenters.map(barycenter => 
                        new THREE.Vector3(...barycenter)
                    );
                }
                
                try {
                    // Create a convex geometry from the vertices of the Voronoi cell
                    const geometry = new ConvexGeometry(vertices);
                    const mesh = new THREE.Mesh(geometry, defaultMaterial);
                    voronoiFacesGroup.add(mesh);
                    cellIndex++;
                } catch (error) {
                    // Skip cells that can't form valid convex geometry
                    console.warn(`Skipped Voronoi cell ${vertexIndex}: ${error.message}`);
                }
            });
            
            console.log(`Drew ${cellIndex} Voronoi cells ${computation.isPeriodic ? '(with MIC correction)' : '(non-periodic)'}`);
        }
        
        // NEW: Unified mesh drawing function with MIC toggle
        function drawMeshes(computation) {
            // Dispose of old geometries and materials to prevent memory leaks
            delaunayGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            voronoiVerticesGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            voronoiEdgesGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            voronoiFacesGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });

            delaunayGroup.clear();
            voronoiVerticesGroup.clear();
            voronoiEdgesGroup.clear();
            voronoiFacesGroup.clear();

            const useMIC = document.getElementById('useMIC').checked;
            
            // Toggle UI based on MIC mode
            document.getElementById('delaunayEdgeWidth').disabled = !useMIC;
            document.getElementById('voronoiEdgeWidth').disabled = !useMIC;

            if (useMIC) {
                // --- Draw using Thick Line (MIC) mode ---
                const delaunayEdgeColorHex = document.getElementById('delaunayEdgeColor').value;
                const delaunayEdgeColorInt = parseInt(delaunayEdgeColorHex.substring(1), 16);
                const delaunayEdgeWidth = parseFloat(document.getElementById('delaunayEdgeWidth').value);
                const delaunayMaterial = new THREE.LineBasicMaterial({ color: delaunayEdgeColorInt });
                createDelaunayEdgesThick(computation, delaunayEdgeWidth, delaunayMaterial);

                const voronoiEdgeColorHex = document.getElementById('voronoiEdgeColor').value;
                const voronoiEdgeColorInt = parseInt(voronoiEdgeColorHex.substring(1), 16);
                const voronoiEdgeWidth = parseFloat(document.getElementById('voronoiEdgeWidth').value);
                const voronoiMaterial = new THREE.LineBasicMaterial({ color: voronoiEdgeColorInt });
                createVoronoiEdgesThick(computation, voronoiEdgeWidth, voronoiMaterial);

            } else {
                // --- Draw using Normal, Thin Line mode ---
                const delaunayGeom = createDelaunayEdgesMIC(computation);
                if (delaunayGeom) {
                    const delaunayMaterial = new THREE.LineBasicMaterial({ color: document.getElementById('delaunayEdgeColor').value });
                    delaunayGroup.add(new THREE.LineSegments(delaunayGeom, delaunayMaterial));
                }

                const voronoiGeom = createVoronoiEdgesMIC(computation);
                if (voronoiGeom) {
                    const voronoiMaterial = new THREE.LineBasicMaterial({ color: document.getElementById('voronoiEdgeColor').value });
                    voronoiEdgesGroup.add(new THREE.LineSegments(voronoiGeom, voronoiMaterial));
                }
            }
            
            // Voronoi vertices are drawn separately
            const voronoiSizeSliderValue = parseFloat(document.getElementById('voronoiSize').value);
            const voronoiVertexSize = 0.05 - voronoiSizeSliderValue; // Convert from reversed slider
            const voronoiVertexColorHex = document.getElementById('voronoiVertexColor').value;
            const voronoiVertexColorInt = parseInt(voronoiVertexColorHex.substring(1), 16);
            const sphereGeometry = new THREE.SphereGeometry(voronoiVertexSize, 8, 8);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: voronoiVertexColorInt,
                emissive: voronoiVertexColorInt,
                emissiveIntensity: 0.3
            });
            
            for (const center of computation.barycenters) {
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(center[0], center[1], center[2]);
                voronoiVerticesGroup.add(sphere);
            }
        }
        
        // Visualize tetrahedra
        function drawTetrahedra(computation) {
            tetrahedraGroup.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            tetrahedraGroup.clear();
            
            if (computation.tetrahedra.length === 0) return;
            
            const tetraColorHex = document.getElementById('tetraColor').value;
            const tetraColorInt = parseInt(tetraColorHex.substring(1), 16);
            const opacity = parseFloat(document.getElementById('tetraOpacity').value);
            
            const material = new THREE.MeshPhongMaterial({
                color: tetraColorInt,
                opacity: opacity,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            for (const tet of computation.tetrahedra) {
                let vertices = tet.map(i => computation.pointsArray[i]);
                
                // Apply MIC correction for periodic tetrahedra
                if (computation.isPeriodic && vertices.length === 4) {
                    // Use first vertex as reference for MIC
                    const reference = vertices[0];
                    vertices = vertices.map((vertex, index) => {
                        if (index === 0) return vertex;
                        
                        // Apply MIC to bring vertex to same periodic image as reference
                        const corrected = [...vertex];
                        for (let i = 0; i < 3; i++) {
                            const delta = vertex[i] - reference[i];
                            if (delta > 0.5) {
                                corrected[i] -= 1.0;
                            } else if (delta < -0.5) {
                                corrected[i] += 1.0;
                            }
                        }
                        return corrected;
                    });
                }
                
                // Create tetrahedron faces
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                
                // Face indices for tetrahedron
                const faces = [
                    [0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3]
                ];
                
                for (const face of faces) {
                    for (const idx of face) {
                        positions.push(vertices[idx][0], vertices[idx][1], vertices[idx][2]);
                    }
                }
                
                geometry.setAttribute('position', 
                    new THREE.BufferAttribute(new Float32Array(positions), 3)
                );
                geometry.computeVertexNormals();
                
                const mesh = new THREE.Mesh(geometry, material);
                tetrahedraGroup.add(mesh);
            }
        }
        
        // Compute Delaunay-Voronoi
        async function computeDelaunayVoronoi() {
            if (!Module) return;
            
            // Add a small delay for live updates to prevent crashes
            if (document.getElementById('liveUpdate').checked) {
                await new Promise(resolve => setTimeout(resolve, 16)); // ~60 FPS
            }

            // Diagnostic check for corrupt input data
            console.log("--- New Computation Triggered ---");
            console.log(`Checking ${currentPoints.length} points before sending to WASM.`);
            let outliersFound = 0;
            for (const p of currentPoints) {
                if (!p || p.length !== 3 || p[0] < 0 || p[0] > 1 || p[1] < 0 || p[1] > 1 || p[2] < 0 || p[2] > 1) {
                    console.error("🔴 OUTLIER DETECTED! This point is outside the [0, 1] unit cube and will corrupt the periodic triangulation:", p);
                    outliersFound++;
                }
            }
            if (outliersFound > 0) {
                console.error(`Found ${outliersFound} outlier points. Halting computation.`);
                setStatus(`Error: Found ${outliersFound} outlier points.`, false);
                return; // Stop execution if data is bad
            }
            console.log("✅ Point data is clean. Proceeding with computation...");
            
            const isPeriodic = document.getElementById('periodicMode').checked;
            
            setStatus('Computing...', false);
            
            try {
                // Create computation instance
                computation = new DelaunayComputation(currentPoints, isPeriodic);
                
                // Run the computation
                await computation.compute(Module);
                
                // Get statistics
                const stats = computation.getStats();
                setStatus(`Success! ${stats.numTetrahedra} tetrahedra, ${stats.numVoronoiEdges} Voronoi edges`, true);
                
                // Update visualization
                drawVertices(computation);
                drawMeshes(computation);
                drawTetrahedra(computation);
                drawVoronoiFaces(computation); // Ensure this is called
                
                // NEW: Create ghost cell tiling
                createGhostCellTiling();
                
                // ACUTENESS ANALYSIS: Run analysis after successful computation
                // Check if any analysis mode is active
                const vertexActive = document.getElementById('vertexAnalysis').checked;
                const edgeActive = document.getElementById('edgeAnalysis').checked;
                const faceCellMode = document.getElementById('faceCellMode').value;
                const analysisActive = vertexActive || edgeActive || faceCellMode !== 'none';
                
                if (analysisActive) {
                    const currentTime = performance.now();
                    const timeSinceLastAnalysis = currentTime - lastAnalysisTime;
                    
                    // Throttle analysis during live updates
                    if (!document.getElementById('liveUpdate').checked || timeSinceLastAnalysis >= ANALYSIS_THROTTLE_MS) {
                        console.log('Running acuteness analysis...');
                        
                        // Use fast analyzer for 500+ points
                        if (currentPoints.length >= 500) {
                            if (!fastAnalyzer) {
                                fastAnalyzer = new FastAcutenessAnalyzer();
                            }
                            console.log('Using FastAcuteness analyzer for', currentPoints.length, 'points');
                            analysisResults = fastAnalyzer.analyze(computation);
                        } else {
                            analysisResults = GeometryAnalysis.analyzeAcuteness(computation);
                        }
                        
                        lastAnalysisTime = currentTime;
                        
                        // Apply analysis coloring if any mode is selected
                        applyAnalysisColoring();
                    } else {
                        console.log(`Skipping analysis - throttled (${timeSinceLastAnalysis.toFixed(0)}ms since last)`);
                        // Still apply coloring with existing results
                        if (analysisResults) {
                            applyAnalysisColoring();
                        }
                    }
                } else {
                    // No analysis active - clear results
                    analysisResults = null;
                }
                
                updateStats();
                
            } catch (error) {
                setStatus(`Error: ${error.message}`, false);
                console.error(error);
            }
        }
        
        // Update statistics
        function updateStats() {
            if (!computation) return;
            
            const stats = computation.getStats();
            const mode = stats.isPeriodic ? 'Periodic' : 'Non-periodic';
            let statusMessage = `${mode} | ${stats.numPoints} points | ${stats.numTetrahedra} tetrahedra`;
            
            // Add average cell acuteness if cells mode is active or if we have cell scores
            if (analysisResults && analysisResults.cellScores) {
                const avgCellScore = (analysisResults.cellScores.reduce((a, b) => a + b, 0) / analysisResults.cellScores.length).toFixed(1);
                statusMessage += ` | Cell avg: ${avgCellScore}`;
            }
            
            setStatus(statusMessage, true);
        }
        
        // ACUTENESS ANALYSIS: Apply analysis coloring based on checked boxes
        function applyAnalysisColoring() {
            if (!analysisResults || !computation) {
                console.warn('No analysis results available', { analysisResults, computation });
                return;
            }
            
            // Check which analysis modes are active
            const vertexActive = document.getElementById('vertexAnalysis').checked;
            const edgeActive = document.getElementById('edgeAnalysis').checked;
            const faceCellMode = document.getElementById('faceCellMode').value;
            
            console.log('Analysis modes:', { vertexActive, edgeActive, faceCellMode });
            
            // Remove any existing analysis coloring
            Visualizer.removeAnalysisColoring();
            
            // If no analysis is active, restore normal visualization
            if (!vertexActive && !edgeActive && faceCellMode === 'none') {
                console.log('No analysis active - restoring normal visualization');
                // Restore normal Voronoi faces and spheres
                drawVoronoiFaces(computation);
                drawMeshes(computation); // This will restore normal spheres
                return;
            }
            
            // Determine which legends to show
            // Rule: If Faces or Cells is selected, show that legend
            // Otherwise, show Vertices and/or Edges legend if they are checked
            const legendsToShow = [];
            
            if (faceCellMode !== 'none') {
                // Faces or Cells is selected - show only that legend
                legendsToShow.push(faceCellMode);
            } else {
                // Neither Faces nor Cells - show Vertices/Edges if checked
                if (vertexActive) legendsToShow.push('vertices');
                if (edgeActive) legendsToShow.push('edges');
            }
            
            console.log('Legends to show:', legendsToShow);
            
            const meshGroups = {
                tetrahedraGroup: tetrahedraGroup,
                voronoiFacesGroup: voronoiFacesGroup,
                voronoiVerticesGroup: voronoiVerticesGroup,
                voronoiEdgesGroup: voronoiEdgesGroup
            };
            
            // Apply vertex analysis if checked
            if (vertexActive) {
                console.log('Applying vertex analysis');
                const thickness = parseFloat(document.getElementById('vertexThickness').value);
                Visualizer.applyVertexColoring(scene, meshGroups.voronoiVerticesGroup, analysisResults.vertexScores, computation, thickness);
            }
            
            // Apply edge analysis if checked
            if (edgeActive) {
                console.log('Applying edge analysis');
                const thickness = parseFloat(document.getElementById('edgeThickness').value);
                Visualizer.applyEdgeColoring(scene, meshGroups.voronoiEdgesGroup, analysisResults.edgeScores, computation, thickness);
            }
            
            // Apply face or cell analysis based on dropdown
            if (faceCellMode !== 'none') {
                if (faceCellMode === 'faces') {
                    console.log('Applying face analysis');
                    Visualizer.applyFaceColoring(scene, meshGroups.voronoiFacesGroup, analysisResults.faceScores, computation);
                } else if (faceCellMode === 'cells') {
                    console.log('Applying cell analysis');
                    Visualizer.applyCellColoring(scene, meshGroups.voronoiFacesGroup, analysisResults.cellScores, computation);
                }
            }
            
            // Now handle legend display based on our rules
            // Remove any existing legends first
            const existingLegends = document.querySelectorAll('.acuteness-legend');
            existingLegends.forEach(legend => legend.remove());
            
            // Only create legends if controls are not hidden
            if (!areControlsHidden()) {
                // Create appropriate legends
                if (legendsToShow.includes('faces')) {
                    Visualizer.createAndShowLegend('FACE', analysisResults.faceScores);
                } else if (legendsToShow.includes('cells')) {
                    Visualizer.createAndShowLegend('CELL', analysisResults.cellScores);
                } else {
                    // Show vertex/edge legends
                    if (legendsToShow.includes('vertices')) {
                        Visualizer.createAndShowLegend('VERTEX', analysisResults.vertexScores);
                    }
                    if (legendsToShow.includes('edges')) {
                        // For multiple legends, offset them vertically
                        const offset = legendsToShow.includes('vertices') ? 250 : 0;
                        Visualizer.createAndShowLegend('EDGE', analysisResults.edgeScores, offset);
                    }
                }
            }
        }
        
        // Set status message
        function setStatus(message, isSuccess) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${isSuccess ? 'success' : 'error'}`;
        }
        
        // Helper function to check if controls are hidden
        function areControlsHidden() {
            const controls = document.getElementById('controls');
            return controls && controls.classList.contains('hidden');
        }
        
        // Legend color and opacity control functions
        
        window.updateLegendOpacityValue = function(index, value) {
            // Update the display value
            const valueSpan = document.getElementById(`legend-opacity-value-${index}`);
            if (valueSpan) {
                valueSpan.textContent = parseFloat(value).toFixed(2);
            }
        };
        
        // ACUTENESS ANALYSIS: Update legend opacities
        window.updateLegendOpacities = function() {
            const opacitySliders = document.querySelectorAll('.acuteness-legend input[type="range"]');
            const opacities = [];
            
            opacitySliders.forEach((slider, index) => {
                opacities.push({
                    min: parseInt(slider.getAttribute('data-range-min')),
                    max: parseInt(slider.getAttribute('data-range-max')),
                    opacity: parseFloat(slider.value)
                });
            });
            
            // Store opacities globally
            window.legendOpacities = opacities;
            window.savedLegendOpacities = opacities; // Save to window object for access from Visualizer.js
            console.log('Updated legend opacities:', opacities);
            
            // Just update the material opacities directly without recreating everything
            if (voronoiFacesGroup && voronoiFacesGroup.children.length > 0) {
                console.log('Updating opacities for', voronoiFacesGroup.children.length, 'meshes');
                console.log('Opacity ranges:', opacities);
                
                // Count how many meshes are in each range
                const rangeCounts = {};
                voronoiFacesGroup.children.forEach(mesh => {
                    if (mesh.userData.score !== undefined) {
                        const score = mesh.userData.score;
                        const range = opacities.find(r => score >= r.min && score <= r.max);
                        if (range) {
                            const key = `${range.min}-${range.max}`;
                            rangeCounts[key] = (rangeCounts[key] || 0) + 1;
                        }
                    }
                });
                console.log('Meshes per range:', rangeCounts);
                
                // Update each mesh's material opacity based on its stored score
                voronoiFacesGroup.children.forEach((mesh, index) => {
                    if (mesh.userData.score !== undefined && mesh.material) {
                        const score = mesh.userData.score;
                        // Find the opacity for this score
                        const opacityRange = opacities.find(range => 
                            score >= range.min && score <= range.max
                        );
                        if (opacityRange) {
                            mesh.material.opacity = opacityRange.opacity;
                            mesh.material.needsUpdate = true;
                        }
                    }
                });
            }
        };
        
        // ACUTENESS ANALYSIS: Update legend colors
        window.updateLegendColors = function(analysisType) {
            if (!analysisType) {
                console.warn('updateLegendColors called without analysisType');
                return;
            }
            
            // Get color inputs for this specific legend
            const legend = document.getElementById(`acuteness-legend-${analysisType.toLowerCase()}`);
            if (!legend) return;
            
            const colorInputs = legend.querySelectorAll('input[type="color"]');
            const colors = [];
            colorInputs.forEach((input, index) => {
                colors[index] = parseInt(input.value.substring(1), 16);
            });
            
            // Store colors specific to this analysis type
            window[`legendCustomColors_${analysisType}`] = colors;
            
            // Reapply coloring
            if (analysisResults) {
                applyAnalysisColoring();
            }
        };
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            frameCount++;
            
            // Update FPS counter
            const now = performance.now();
            if (now - lastFPSUpdate >= 1000) {
                currentFPS = frameCount * 1000 / (now - lastFPSUpdate);
                frameCount = 0;
                lastFPSUpdate = now;
                
                // Update performance stats if visible
                if (document.getElementById('showPerformanceStats').checked) {
                    updatePerformanceStats();
                }
            }
            
            // Apply growth if enabled
            if (growthEnabled && computation && analysisResults) {
                // Apply physics-based growth
                const newPoints = physicsGrowthSystem.applyGrowth(currentPoints, computation, analysisResults);
                
                // Check if points actually changed
                let changed = false;
                for (let i = 0; i < newPoints.length; i++) {
                    if (newPoints[i][0] !== currentPoints[i][0] || 
                        newPoints[i][1] !== currentPoints[i][1] || 
                        newPoints[i][2] !== currentPoints[i][2]) {
                        changed = true;
                        break;
                    }
                }
                
                if (changed) {
                    currentPoints = newPoints;
                    
                    // Update growth statistics display
                    const stats = physicsGrowthSystem.getStats();
                    document.getElementById('growthStats').textContent = 
                        `Grow: ${stats.growingPoints} | Shrink: ${stats.shrinkingPoints} | Avg Δ: ${stats.averageDisplacement.toFixed(4)} | Max Δ: ${stats.maxDisplacement.toFixed(4)}`;
                    
                    // Update physics statistics display
                    document.getElementById('physicsStats').textContent = 
                        `Physics: ${stats.physicsSteps} steps | Equilibrium: ${stats.equilibriumReached ? 'Yes' : 'No'}`;
                    
                    // Recompute if live update is enabled
                    if (document.getElementById('liveUpdate').checked) {
                        const updateFrequency = parseInt(document.getElementById('updateFrequency').value);
                        if (frameCount % updateFrequency === 0) {
                            computeDelaunayVoronoi();
                        }
                    } else {
                        drawVertices(computation);
                    }
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }
        
        // Initialize everything
        window.PeriodicDelaunayModule().then(module => {
            Module = module;
            setStatus('Module loaded', true);
            
            // Initialize the Visualizer module with THREE.js objects
            Visualizer.initVisualizer(THREE, ConvexGeometry);
            
            initThree();
            
            // Generate initial points
            const numPoints = parseInt(document.getElementById('numPoints').value);
            const minDist = parseFloat(document.getElementById('minDistance').value);
            const usePoisson = document.getElementById('poissonSampling').checked;
            const points = usePoisson ? 
                generatePoissonPoints(numPoints, minDist) : 
                generateWellDistributedPoints(numPoints, minDist);
            currentPoints = points;

            // Initialize velocities
            velocities = currentPoints.map(() => [(Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)]);
            
            computeDelaunayVoronoi();
            
            // Set initial checkbox states
            document.getElementById('showVertices').checked = true;
            document.getElementById('showDelaunay').checked = true;
            document.getElementById('showTetrahedra').checked = true;
            document.getElementById('showVoronoiVertices').checked = true;
            document.getElementById('showVoronoiEdges').checked = true;
            
            // Set cells mode as default for visualization
            document.getElementById('faceCellMode').value = 'cells';
            document.getElementById('showVoronoiFaces').checked = true;
            document.getElementById('showBoundary').checked = true;
            
            // Set up event listeners
            document.getElementById('showVertices').addEventListener('change', (e) => {
                verticesGroup.visible = e.target.checked;
            });
            
            document.getElementById('showDelaunay').addEventListener('change', (e) => {
                delaunayGroup.visible = e.target.checked;
            });
            
            document.getElementById('showVoronoiVertices').addEventListener('change', (e) => {
                voronoiVerticesGroup.visible = e.target.checked;
            });
            
            document.getElementById('showVoronoiEdges').addEventListener('change', (e) => {
                voronoiEdgesGroup.visible = e.target.checked;
            });
            
            document.getElementById('showTetrahedra').addEventListener('change', (e) => {
                tetrahedraGroup.visible = e.target.checked;
            });
            
            document.getElementById('showBoundary').addEventListener('change', (e) => {
                boundaryGroup.visible = e.target.checked;
            });
            
            document.getElementById('showVoronoiFaces').addEventListener('change', (e) => {
                voronoiFacesGroup.visible = e.target.checked;
            });
            

            
            const regenerateButton = document.getElementById('regenerate');
            if (!regenerateButton) {
                console.error('Regenerate button not found!');
                return;
            }
            
            regenerateButton.addEventListener('click', () => {
                console.log('Regenerate button clicked!');
                try {
                    const numPoints = parseInt(document.getElementById('numPoints').value);
                    const minDist = parseFloat(document.getElementById('minDistance').value);
                    const usePoisson = document.getElementById('poissonSampling').checked;
                    
                    console.log(`Generating ${numPoints} points with minDist=${minDist}, usePoisson=${usePoisson}`);
                    
                    const points = usePoisson ? 
                        generatePoissonPoints(numPoints, minDist) : 
                        generateWellDistributedPoints(numPoints, minDist);
                    
                    console.log(`Generated ${points.length} points`);
                    
                    currentPoints = points;
                    velocities = currentPoints.map(() => [(Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)]);
                    
                    // Reset physics growth system if it exists
                    if (physicsGrowthSystem) {
                        physicsGrowthSystem.reset();
                    }
                    
                    computeDelaunayVoronoi();
                    setStatus(`Generated ${points.length} points successfully`, true);
                } catch (error) {
                    console.error('Error in regenerate button:', error);
                    setStatus(`Error generating points: ${error.message}`, false);
                }
            });
            
            document.getElementById('recompute').addEventListener('click', () => {
                computeDelaunayVoronoi();
            });
            
            document.getElementById('periodicMode').addEventListener('change', () => {
                computeDelaunayVoronoi();
            });
            
            // Boundary scale control
            document.getElementById('boundaryScale').addEventListener('input', (e) => {
                document.getElementById('boundaryScaleValue').textContent = e.target.value + '%';
            });
            
            document.getElementById('boundaryScale').addEventListener('change', () => {
                // Regenerate points with new scale when slider is released
                regenerateButton.click();
            });
            
            // Growth System Controls
            document.getElementById('enableGrowth').addEventListener('change', (e) => {
                growthEnabled = e.target.checked;
                if (growthEnabled) {
                    // Initialize physics growth system if not already done
                    if (!physicsGrowthSystem) {
                        physicsGrowthSystem = new PhysicsGrowthSystem({
                            threshold: parseFloat(document.getElementById('growthThreshold').value),
                            growthPower: parseFloat(document.getElementById('growthPower').value),
                            normalize: document.getElementById('growthNormalize').checked,
                            mode: document.getElementById('growthMode').value,
                            baseGrowthRate: parseFloat(document.getElementById('growthRate').value),
                            forceStrength: parseFloat(document.getElementById('forceStrength').value),
                            equilibriumPrecision: parseFloat(document.getElementById('equilibriumPrecision').value),
                            maxPhysicsSteps: parseInt(document.getElementById('maxPhysicsSteps').value),
                            stepMode: document.getElementById('stepMode').value
                        });
                    }
                    document.getElementById('growthStats').textContent = 'Dynamics active - waiting for data...';
                    
                    // Ensure cells mode is selected for growth to work
                    if (document.getElementById('faceCellMode').value === 'none') {
                        document.getElementById('faceCellMode').value = 'cells';
                        // Trigger analysis
                        if (computation) {
                            console.log('Triggering analysis for growth system...');
                            // Run analysis
                            if (currentPoints.length >= 500) {
                                if (!fastAnalyzer) {
                                    fastAnalyzer = new FastAcutenessAnalyzer();
                                }
                                analysisResults = fastAnalyzer.analyze(computation);
                            } else {
                                analysisResults = GeometryAnalysis.analyzeAcuteness(computation);
                            }
                            applyAnalysisColoring();
                        }
                    }
                } else {
                    document.getElementById('growthStats').textContent = 'Dynamics inactive';
                    document.getElementById('physicsStats').textContent = 'Physics: 0 steps | Equilibrium: No';
                }
            });
            
            document.getElementById('growthRate').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('growthRateValue').textContent = value.toFixed(4);
                if (physicsGrowthSystem) {
                    physicsGrowthSystem.updateConfig({ baseGrowthRate: value });
                }
            });
            
            document.getElementById('growthDamping').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('growthDampingValue').textContent = value.toFixed(2);
                if (physicsGrowthSystem) {
                    physicsGrowthSystem.updateConfig({ damping: value });
                }
            });
            
            document.getElementById('growthMaxDelta').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('growthMaxDeltaValue').textContent = value.toFixed(3);
                // Note: maxDelta not used in physics system, keeping for UI compatibility
            });
            
            document.getElementById('growthThreshold').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('growthThresholdValue').textContent = value;
                if (physicsGrowthSystem) {
                    physicsGrowthSystem.updateConfig({ threshold: value });
                }
                
                // Update cell counts in legend when threshold changes
                if (analysisResults && analysisResults.cellScores) {
                    Visualizer.updateCellCounts('CELL', analysisResults.cellScores);
                }
            });
            
            document.getElementById('growthMode').addEventListener('change', (e) => {
                if (physicsGrowthSystem) {
                    physicsGrowthSystem.updateConfig({ mode: e.target.value });
                }
            });
            
            document.getElementById('growthPower').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('growthPowerValue').textContent = value.toFixed(1);
                if (physicsGrowthSystem) {
                    physicsGrowthSystem.updateConfig({ growthPower: value });
                }
            });
            
            document.getElementById('forceStrength').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('forceStrengthValue').textContent = value.toFixed(1);
                if (physicsGrowthSystem) {
                    physicsGrowthSystem.updateConfig({ forceStrength: value });
                }
            });
            
            document.getElementById('equilibriumPrecision').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('equilibriumPrecisionValue').textContent = value.toFixed(4);
                if (physicsGrowthSystem) {
                    physicsGrowthSystem.updateConfig({ equilibriumPrecision: value });
                }
            });
            
            document.getElementById('maxPhysicsSteps').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                document.getElementById('maxPhysicsStepsValue').textContent = value;
                if (physicsGrowthSystem) {
                    physicsGrowthSystem.updateConfig({ maxPhysicsSteps: value });
                }
            });
            
            document.getElementById('physicsStepsPerAnalysis').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                document.getElementById('physicsStepsPerAnalysisValue').textContent = value;
                if (physicsGrowthSystem) {
                    physicsGrowthSystem.updateConfig({ physicsStepsPerAnalysis: value });
                }
            });
            
            document.getElementById('stepMode').addEventListener('change', (e) => {
                if (physicsGrowthSystem) {
                    // Stop continuous mode if switching away from it
                    if (physicsGrowthSystem.isContinuousMode()) {
                        physicsGrowthSystem.stopContinuousMode();
                    }
                    
                    physicsGrowthSystem.updateConfig({ stepMode: e.target.value });
                }
                
                // Show/hide manual step button based on mode
                const stepButton = document.getElementById('manualStep');
                const stepMode = e.target.value;
                
                if (stepMode === 'manual') {
                    stepButton.style.display = 'block';
                    stepButton.textContent = 'Step';
                } else if (stepMode === 'continuous') {
                    stepButton.style.display = 'block';
                    stepButton.textContent = 'Start';
                } else {
                    stepButton.style.display = 'none';
                }
            });
            
            document.getElementById('manualStep').addEventListener('click', () => {
                if (!physicsGrowthSystem || !computation || !analysisResults) return;
                
                const stepMode = document.getElementById('stepMode').value;
                const stepButton = document.getElementById('manualStep');
                
                if (stepMode === 'continuous') {
                    // Handle continuous mode start/stop
                    if (physicsGrowthSystem.isContinuousMode()) {
                        // Stop continuous mode
                        physicsGrowthSystem.stopContinuousMode();
                        stepButton.textContent = 'Start';
                    } else {
                        // Start continuous mode
                        const continuousCallback = (onComplete, skipAnalysis = false) => {
                            if (!skipAnalysis) {
                                // Full analysis step - recompute everything
                                const newPoints = physicsGrowthSystem.performContinuousStep(currentPoints, computation, analysisResults, false);
                                currentPoints = newPoints;
                                
                                // Recompute full Delaunay/Voronoi for new analysis
                                computeDelaunayVoronoi();
                            } else {
                                // Physics-only step - just update positions
                                const newPoints = physicsGrowthSystem.performContinuousStep(currentPoints, computation, analysisResults, true);
                                currentPoints = newPoints;
                                
                                // Just update vertex positions without full recomputation
                                drawVertices(computation);
                            }
                            
                            // Update statistics
                            const stats = physicsGrowthSystem.getStats();
                            document.getElementById('growthStats').textContent = 
                                `Grow: ${stats.growingPoints} | Shrink: ${stats.shrinkingPoints} | Avg Δ: ${stats.averageDisplacement.toFixed(4)} | Max Δ: ${stats.maxDisplacement.toFixed(4)}`;
                            document.getElementById('physicsStats').textContent = 
                                `Physics: ${stats.physicsSteps} steps | Equilibrium: ${stats.equilibriumReached ? 'Yes' : 'No'}`;
                            
                            // Update performance stats
                            updatePerformanceStats();
                            
                            // Call completion callback
                            if (onComplete) onComplete();
                        };
                        
                        physicsGrowthSystem.startContinuousMode(currentPoints, computation, analysisResults, continuousCallback);
                        stepButton.textContent = 'Stop';
                    }
                } else {
                    // Handle manual step mode
                    const newPoints = physicsGrowthSystem.performManualStep(currentPoints, computation, analysisResults);
                    currentPoints = newPoints;
                    
                    // Update statistics
                    const stats = physicsGrowthSystem.getStats();
                    document.getElementById('growthStats').textContent = 
                        `Grow: ${stats.growingPoints} | Shrink: ${stats.shrinkingPoints} | Avg Δ: ${stats.averageDisplacement.toFixed(4)} | Max Δ: ${stats.maxDisplacement.toFixed(4)}`;
                    document.getElementById('physicsStats').textContent = 
                        `Physics: ${stats.physicsSteps} steps | Equilibrium: ${stats.equilibriumReached ? 'Yes' : 'No'}`;
                    
                    // Recompute visualization
                    computeDelaunayVoronoi();
                    
                    // Update performance stats
                    updatePerformanceStats();
                }
            });
            
            document.getElementById('showPerformanceStats').addEventListener('change', (e) => {
                document.getElementById('performanceStats').style.display = e.target.checked ? 'block' : 'none';
            });
            
            function updatePerformanceStats() {
                if (!physicsGrowthSystem || !document.getElementById('showPerformanceStats').checked) {
                    return;
                }
                
                const stats = physicsGrowthSystem.getPerformanceStats();
                
                // Update timing stats
                document.getElementById('perfTotalTime').textContent = stats.totalTime.toFixed(2) + 'ms';
                document.getElementById('perfAcutenessTime').textContent = stats.acutenessTime.toFixed(2) + 'ms';
                document.getElementById('perfPhysicsTime').textContent = stats.physicsTime.toFixed(2) + 'ms';
                document.getElementById('perfVoronoiTime').textContent = stats.voronoiTime.toFixed(2) + 'ms';
                
                // Update physics debug info
                if (stats.physicsDebug) {
                    document.getElementById('perfActiveCells').textContent = stats.physicsDebug.activeCount;
                    document.getElementById('perfAvgNeighbors').textContent = stats.physicsDebug.averageNeighborsPerCell.toFixed(1);
                }
                
                // Update FPS
                document.getElementById('perfFPS').textContent = currentFPS.toFixed(1);
            }
            
            document.getElementById('growthNormalize').addEventListener('change', (e) => {
                if (physicsGrowthSystem) {
                    physicsGrowthSystem.updateConfig({ normalize: e.target.checked });
                }
            });
            
            document.getElementById('resetGrowth').addEventListener('click', () => {
                if (physicsGrowthSystem) {
                    // Stop continuous mode if active
                    if (physicsGrowthSystem.isContinuousMode()) {
                        physicsGrowthSystem.stopContinuousMode();
                        // Update button text
                        const stepButton = document.getElementById('manualStep');
                        if (document.getElementById('stepMode').value === 'continuous') {
                            stepButton.textContent = 'Start';
                        }
                    }
                    
                    physicsGrowthSystem.reset();
                    document.getElementById('growthStats').textContent = growthEnabled ? 'Dynamics reset - waiting for data...' : 'Dynamics inactive';
                    document.getElementById('physicsStats').textContent = 'Physics: 0 steps | Equilibrium: No';
                }
            });
            
            // Size and color controls
            document.getElementById('delaunaySize').addEventListener('change', () => {
                drawVertices(computation);
            });
            
            document.getElementById('vertexColor').addEventListener('change', () => {
                drawVertices(computation);
            });
            
            document.getElementById('delaunayEdgeColor').addEventListener('change', () => {
                drawMeshes(computation);
            });
            
            // NEW: Edge width controls
            document.getElementById('delaunayEdgeWidth').addEventListener('change', () => {
                drawMeshes(computation);
            });
            
            // Handle reversed slider for voronoiSize
            const voronoiSizeSlider = document.getElementById('voronoiSize');
            const voronoiSizeValue = document.getElementById('voronoiSizeValue');
            
            function updateVoronoiSize() {
                // Convert reversed slider value to actual size
                const sliderValue = parseFloat(voronoiSizeSlider.value);
                const actualSize = 0.05 - sliderValue; // Reverse the value
                
                // Update display with 4 decimal places
                voronoiSizeValue.textContent = actualSize.toFixed(4);
                
                // Always redraw normal spheres first
                drawMeshes(computation);
                // Then reapply any active analysis
                applyAnalysisColoring();
            }
            
            voronoiSizeSlider.addEventListener('input', updateVoronoiSize);
            voronoiSizeSlider.addEventListener('change', updateVoronoiSize);
            
            document.getElementById('voronoiVertexColor').addEventListener('change', () => {
                // Always redraw normal spheres first
                drawMeshes(computation);
                // Then reapply any active analysis
                applyAnalysisColoring();
            });

            document.getElementById('voronoiEdgeColor').addEventListener('change', () => {
                drawMeshes(computation);
            });
            
            // NEW: Voronoi edge width control
            document.getElementById('voronoiEdgeWidth').addEventListener('change', () => {
                drawMeshes(computation);
            });
            
            // Face color and opacity controls
            document.getElementById('voronoiFaceColor').addEventListener('change', () => {
                drawVoronoiFaces(computation);
                createGhostCellTiling(); // Update ghost cells too
            });
            
            document.getElementById('voronoiFaceOpacity').addEventListener('change', () => {
                drawVoronoiFaces(computation);
                createGhostCellTiling(); // Update ghost cells too
            });
            
            document.getElementById('tetraColor').addEventListener('change', () => {
                drawTetrahedra(computation);
            });
            
            document.getElementById('tetraOpacity').addEventListener('change', () => {
                drawTetrahedra(computation);
            });
            
            // NEW: Event listeners for MIC and Ghost Cell controls
            document.getElementById('useMIC').addEventListener('change', () => {
                drawMeshes(computation);
                createGhostCellTiling();
            });
            
            document.getElementById('showGhostCells').addEventListener('change', () => {
                createGhostCellTiling();
            });
            

            
            // NEW: Control panel toggle
            document.getElementById('controls-toggle').addEventListener('click', () => {
                const controls = document.getElementById('controls');
                const toggle = document.getElementById('controls-toggle');
                const content = document.getElementById('controls-content');
                const legends = document.querySelectorAll('.acuteness-legend');
                
                if (controls.classList.contains('hidden')) {
                    controls.classList.remove('hidden');
                    content.style.display = 'block';
                    toggle.textContent = 'hide';
                    toggle.title = 'Hide Controls';
                    // Show legends
                    legends.forEach(legend => {
                        legend.style.display = 'block';
                    });
                    // Recreate legends if analysis is active
                    if (analysisResults) {
                        applyAnalysisColoring();
                    }
                } else {
                    controls.classList.add('hidden');
                    content.style.display = 'none';
                    toggle.textContent = 'show';
                    toggle.title = 'Show Controls';
                    // Hide legends
                    legends.forEach(legend => {
                        legend.style.display = 'none';
                    });
                }
            });
            
            // Background color control
            document.getElementById('backgroundColor').addEventListener('change', (e) => {
                scene.background = new THREE.Color(e.target.value);
            });
            
            // ACUTENESS ANALYSIS: Event listeners for new checkbox controls
            
            // Update value displays
            document.getElementById('vertexThickness').addEventListener('input', (e) => {
                document.getElementById('vertexThicknessValue').textContent = parseFloat(e.target.value).toFixed(3);
                if (document.getElementById('vertexAnalysis').checked) {
                    applyAnalysisColoring();
                }
            });
            
            document.getElementById('edgeThickness').addEventListener('input', (e) => {
                document.getElementById('edgeThicknessValue').textContent = parseFloat(e.target.value).toFixed(3);
                if (document.getElementById('edgeAnalysis').checked) {
                    applyAnalysisColoring();
                }
            });
            

            
            // Checkbox event listeners
            document.getElementById('vertexAnalysis').addEventListener('change', () => {
                applyAnalysisColoring();
                updateStats();
            });
            
            document.getElementById('edgeAnalysis').addEventListener('change', () => {
                applyAnalysisColoring();
                updateStats();
            });
            
            // Dropdown event listener
            document.getElementById('faceCellMode').addEventListener('change', () => {
                applyAnalysisColoring();
                updateStats();
            });
            
            document.getElementById('runTests').addEventListener('click', () => {
                console.log('Running GeometryAnalysis unit tests...');
                runGeometryAnalysisTests();
            });
            
            document.getElementById('recomputeAnalysis').addEventListener('click', () => {
                if (computation) {
                    console.log('Recomputing analysis...');
                    
                    // Use fast analyzer for 500+ points
                    if (currentPoints.length >= 500) {
                        if (!fastAnalyzer) {
                            fastAnalyzer = new FastAcutenessAnalyzer();
                        }
                        console.log('Using FastAcuteness analyzer for', currentPoints.length, 'points');
                        analysisResults = fastAnalyzer.analyze(computation);
                    } else {
                        // Use standard analyzer for smaller datasets
                        analysisResults = GeometryAnalysis.analyzeAcuteness(computation);
                    }
                    
                    applyAnalysisColoring();
                    updateStats();
                } else {
                    console.warn('No computation available to analyze');
                }
            });
            




            animate();
            
        }).catch(err => {
            console.error('Failed to load module:', err);
            setStatus('Failed to load module', false);
        });
    </script>
</body>
</html> 